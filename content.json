{"meta":{"title":"程序猿小站","subtitle":null,"description":null,"author":"橘子","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-11-21T09:59:19.000Z","updated":"2018-11-21T09:59:57.668Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-21T09:59:22.000Z","updated":"2018-11-21T09:59:43.575Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Elasticsearch-6.2.4插件开发四：分析插件开发","slug":"Elasticsearch-6.2.4插件开发四：分析插件开发","date":"2018-11-27T09:23:21.109Z","updated":"2018-11-28T02:39:27.301Z","comments":true,"path":"2018/11/27/Elasticsearch-6.2.4插件开发四：分析插件开发/","link":"","permalink":"http://yoursite.com/2018/11/27/Elasticsearch-6.2.4插件开发四：分析插件开发/","excerpt":"","text":"分析器介绍分析器内部分为Analyzer、CharFilter、Tokenizer、TokenFilter。 其中Analyzer由其他三部分组成，Tokenizer为必要部分，其他两个非必要。 数据进入分析器的流程： Analyzer：分析器，对数据进行过滤、分词等操作 CharFilter：字符过滤器，最开始处理数据，过滤指定字符，如html标签过滤 Tokenizer：分词器，对数据进行分词操作，作为Analyzer的核心 TokenFilter：分词过滤器，对分词进行过滤，如lowercase将分词中存在的大写字母过滤成小写 分词结果解析12345GET _analyze&#123; \"analyzer\": \"standard\", \"text\": [\"测试test\"]&#125; 12345678910111213141516171819202122232425&#123; \"tokens\": [ &#123; \"token\": \"测\", \"start_offset\": 0, \"end_offset\": 1, \"type\": \"&lt;IDEOGRAPHIC&gt;\", \"position\": 0 &#125;, &#123; \"token\": \"试\", \"start_offset\": 1, \"end_offset\": 2, \"type\": \"&lt;IDEOGRAPHIC&gt;\", \"position\": 1 &#125;, &#123; \"token\": \"test\", \"start_offset\": 2, \"end_offset\": 6, \"type\": \"&lt;ALPHANUM&gt;\", \"position\": 2 &#125; ]&#125; 文本经过分词后会返回一个分词数组： token表示分词 start_offset和end_offset表示该分词在文本中的偏移位置 type表示该分词的类型 position表示分词的位置，注：match_phrase以position为标准 插件类插件类需要继承Plugin类以及实现AnalysisPlugin接口，实现AnalysisPlugin接口可以重新其中的方法来提供指定的分析器： 123456789101112131415public interface AnalysisPlugin &#123; default Map&lt;String, AnalysisProvider&lt;CharFilterFactory&gt;&gt; getCharFilters() &#123; return emptyMap(); &#125; default Map&lt;String, AnalysisProvider&lt;TokenFilterFactory&gt;&gt; getTokenFilters() &#123; return emptyMap(); &#125; default Map&lt;String, AnalysisProvider&lt;TokenizerFactory&gt;&gt; getTokenizers() &#123; return emptyMap(); &#125; default Map&lt;String, AnalysisProvider&lt;AnalyzerProvider&lt;? extends Analyzer&gt;&gt;&gt; getAnalyzers() &#123; return emptyMap(); &#125; ......&#125; Tokenizer开发Tokenizer文件结构： 插件类中重写getTokenizers 方法，添加分词器工厂： 12345678public class TestAnalyzerPlugin extends Plugin implements AnalysisPlugin &#123; @Override public Map&lt;String, AnalysisProvider&lt;TokenizerFactory&gt;&gt; getTokenizers() &#123; Map&lt;String, AnalysisProvider&lt;TokenizerFactory&gt;&gt; tokenizers = new HashMap&lt;&gt;(); tokenizers.put(\"test\", TestTokenizerFactory::new); return tokenizers; &#125;&#125; 定义TokenizerFactory： 12345678910111213141516public class TestTokenizerFactory extends AbstractTokenizerFactory &#123; // 自己定义配置类，非必须 private AnalysisConfig config; public TestTokenizerFactory(IndexSettings indexSettings, Environment env, String name, Settings settings) &#123; super(indexSettings, name, settings); // 可在设置tokenizer时读取相关配置 this.config = new AnalysisConfig(settings); &#125; @Override public Tokenizer create() &#123; // 构建tokenizer return new TestTokenizer(this.config); &#125;&#125; 配置类： 12345678910111213public class AnalysisConfig &#123; private boolean testConfig = true; public AnalysisConfig(Settings settings) &#123; // 在setting中读取配置，如果没有则默认为true this.testConfig = settings.getAsBoolean(\"testConfig\", true); &#125; public boolean isTestConfig() &#123; return testConfig; &#125;&#125; Tokenizer： 在此之前，先看看外部对分析器的调用： 123456789// 获取分析器的tokenStream，如果该分析器中只包括了Tokenizer，则tokenStream就是该分析器的TokenizerTokenStream tokenStream = analyzer.tokenStream(fieldName, contents))；tokenStream.reset();// 循环调用，每次获取一个分词while (tokenStream.incrementToken()) &#123; // 得到分词的偏移量 OffsetAttribute attr = tokenStream.getAttribute(OffsetAttribute.class);&#125;tokenStream.end(); 定义Tokenizer： 1234567891011121314151617181920212223242526272829303132333435363738394041public class TestTokenizer extends Tokenizer &#123; // 分词结果 private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class); // 偏移量 private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class); // 位置 private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class); private AnalysisConfig config; public TestTokenizer(AnalysisConfig config) &#123; this.config = config; &#125; @Override public void reset() throws IOException &#123; // 分词前执行，如果有设置变量需要在这里清理资源 super.reset(); &#125; @Override public void end() throws IOException &#123; super.end(); &#125; /** * 将循环调用改方法 */ @Override public boolean incrementToken() throws IOException &#123; // 清理上一次分词的数据 clearAttributes(); // 从Reader中读出数据：input.read()，可存在局部变量之中 // 存储分词信息 termAtt.append(term); offsetAtt.setOffset(startOffset, endOffset); posIncrAtt.setPositionIncrement(offset); // 返回true表示分词还没结束 return true; &#125;&#125;","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]},{"title":"Elasticsearch-6.2.4插件开发三：高亮插件开发","slug":"Elasticsearch-6.2.4插件开发三：高亮插件开发","date":"2018-11-27T06:23:38.064Z","updated":"2018-11-28T02:39:09.265Z","comments":true,"path":"2018/11/27/Elasticsearch-6.2.4插件开发三：高亮插件开发/","link":"","permalink":"http://yoursite.com/2018/11/27/Elasticsearch-6.2.4插件开发三：高亮插件开发/","excerpt":"","text":"首先，我们需要继承Plugin类使插件可以被es初始化时候加载，然后根据实际功能具体实现不同的插件接口，重写相关方法。高亮是搜索阶段的处理，我们可以看看SearchPlugin里的部分代码： 1234567891011121314151617181920212223242526272829303132333435363738public interface SearchPlugin &#123; default List&lt;ScoreFunctionSpec&lt;?&gt;&gt; getScoreFunctions() &#123; return emptyList(); &#125; default List&lt;SearchExtensionSpec&lt;SignificanceHeuristic, SignificanceHeuristicParser&gt;&gt; getSignificanceHeuristics() &#123; return emptyList(); &#125; default List&lt;SearchExtensionSpec&lt;MovAvgModel, MovAvgModel.AbstractModelParser&gt;&gt; getMovingAverageModels() &#123; return emptyList(); &#125; default List&lt;FetchSubPhase&gt; getFetchSubPhases(FetchPhaseConstructionContext context) &#123; return emptyList(); &#125; default List&lt;SearchExtSpec&lt;?&gt;&gt; getSearchExts() &#123; return emptyList(); &#125; // 高亮 default Map&lt;String, Highlighter&gt; getHighlighters() &#123; return emptyMap(); &#125; default List&lt;SuggesterSpec&lt;?&gt;&gt; getSuggesters() &#123; return emptyList(); &#125; default List&lt;QuerySpec&lt;?&gt;&gt; getQueries() &#123; return emptyList(); &#125; default List&lt;AggregationSpec&gt; getAggregations() &#123; return emptyList(); &#125; default List&lt;PipelineAggregationSpec&gt; getPipelineAggregations() &#123; return emptyList(); &#125; default List&lt;RescorerSpec&lt;?&gt;&gt; getRescorers() &#123; return emptyList(); &#125; // 以下省略&#125; SearchPlugin下的方法包括了搜索阶段的各种处理，其中就有我们需要的getHighlighters方法，我们只要实现SearchPlugin接口，重写getHighlighter方法即可。 高亮插件文件结构： 12345678public class TestHighlightSearchPlugin extends Plugin implements SearchPlugin &#123; @Override public Map&lt;String, Highlighter&gt; getHighlighters() &#123; // 返回高亮器 return Collections.singletonMap(TestHighlighter.NAME, new TestHighlighter()); &#125;&#125; 需要返回一个map，key-value具体对应了高亮器的唯一标识，和一个实现了Highlighter接口的高亮器。 123456public interface Highlighter &#123; HighlightField highlight(HighlighterContext highlighterContext); boolean canHighlight(FieldMapper fieldMapper);&#125; Highlighter接口里面就很简单了，只有两个方法，其中canHighlight中可以定义高亮器的使用限制条件，就像fvh需要设置&quot;term_vector&quot;: &quot;with_positions_offsets&quot;一样，不需要限制的话默认返回true就行；而重点就是highlight方法了，可以在highlighterContext中拿到搜索返回的内容、分析器、分词等，自己定义高亮逻辑。","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]},{"title":"Elasticsearch-6.2.4插件源码调试","slug":"Elasticsearch-6.2.4插件源码调试","date":"2018-11-27T06:18:26.804Z","updated":"2018-11-28T02:39:40.058Z","comments":true,"path":"2018/11/27/Elasticsearch-6.2.4插件源码调试/","link":"","permalink":"http://yoursite.com/2018/11/27/Elasticsearch-6.2.4插件源码调试/","excerpt":"","text":"正常es测试插件必须把插件打包好并放进plugins目录中，这样是很不方便的。而在源码中开发插件（将插件代码放入es源码里面）就可以不用每次都得把插件编译打包了，org.elasticsearch.node.Node（节点类，es启动时初始化节点的各个部分）的构造函数中就存在一个入口，可以在es启动时将我们的插件类加载进去。（ps：源码启动es可以看另一篇文章） 12345678public Node(Environment environment) &#123; // 这里传入了一个空的集合，从下面可以看出这是插件的集合 this(environment, Collections.emptyList());&#125;protected Node(final Environment environment, Collection&lt;Class&lt;? extends Plugin&gt;&gt; classpathPlugins) &#123; // 节点初始化操作 &#125; 对于这个入口，可以写一个简单工厂类来加载我们的插件： 1234public Node(Environment environment) &#123; //this(environment, Collections.emptyList()); this(environment, CreatePluginClassFactory.createPlugin( \"test\"));&#125; 12345678910111213141516public class CreatePluginClassFactory &#123; public static Collection&lt;Class&lt;? extends Plugin&gt;&gt; createPlugin(String ... pluginName) &#123; Collection&lt;Class&lt;? extends Plugin&gt;&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; pluginName.length; i++) &#123; switch (pluginName[i]) &#123; case \"test\" : // 继承了Plugin的插件类 result.add(TestPlugin.class); break; default: break; &#125; &#125; return result; &#125;&#125; 这样将插件类加载进去后，在源码重启es便可以调试代码。","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]},{"title":"Elasticsearch-6.2.4插件开发二：插件的加载过程","slug":"Elasticsearch-6.2.4插件开发二：插件的加载过程","date":"2018-11-22T03:20:17.736Z","updated":"2018-11-28T02:39:17.868Z","comments":true,"path":"2018/11/22/Elasticsearch-6.2.4插件开发二：插件的加载过程/","link":"","permalink":"http://yoursite.com/2018/11/22/Elasticsearch-6.2.4插件开发二：插件的加载过程/","excerpt":"","text":"从源码看插件的加载过程插件是在节点（org.elasticsearch.node.Node）初始化的时候加载的，下面列举出部分关键代码，以搜索服务为例来介绍插件的加载过程： 1234567891011121314151617181920212223242526272829public Node(Environment environment) &#123; this(environment, Collections.emptyList());&#125; protected Node(final Environment environment, Collection&lt;Class&lt;? extends Plugin&gt;&gt; classpathPlugins) &#123; ...... // 插件服务从以下几个地方加载插件：plugins和modules文件夹、classpathPlugins集合（集合为空，可在开发时使用） this.pluginsService = new PluginsService(tmpSettings, environment.configFile(), environment.modulesFile(), environment.pluginsFile(), classpathPlugins); ...... // 初始化search模块，可以看到实现SearchPlugin接口的插件类将会被过滤出来 SearchModule searchModule = new SearchModule(settings, false, pluginsService.filterPlugins(SearchPlugin.class)); ...... // 各个模块整合成搜索服务searchService final SearchService searchService = newSearchService(clusterService, indicesService, threadPool, scriptModule.getScriptService(), bigArrays, searchModule.getFetchPhase(), responseCollectorService); ...... modules.add(b -&gt; &#123; ...... // 注入实例 b.bind(SearchPhaseController.class).toInstance(new SearchPhaseController(settings, searchService::createReduceContext)); ...... &#125; ......&#125; 接着我们来看pluginsService的构造函数： 1234567public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection&lt;Class&lt;? extends Plugin&gt;&gt; classpathPlugins) &#123; ...... // 以classpathPlugins的形式作为参考，可以看到需要继承Plugin抽象类 for (Class&lt;? extends Plugin&gt; pluginClass : classpathPlugins) &#123; ...... &#125;&#125; 可以看出，首先，我们要有一个类继承Plugin类并且某些服务需要实现相应的插件接口（旧版es只需要继承Plugin便可修改各个模块，相关接口现已弃用）才能被发现。 搜索插件的加载过程接下来我们以搜索插件中的高亮部分为例，看看如何以插件的形式给es添加新的高亮类型。 首先是searchModule的构造函数： 12345678910111213141516171819public SearchModule(Settings settings, boolean transportClient, List&lt;SearchPlugin&gt; plugins) &#123; this.settings = settings; this.transportClient = transportClient; registerSuggesters(plugins); // 高亮加载 highlighters = setupHighlighters(settings, plugins); registerScoreFunctions(plugins); registerQueryParsers(plugins); registerRescorers(plugins); registerSorts(); registerValueFormats(); registerSignificanceHeuristics(plugins); registerMovingAverageModels(plugins); registerAggregations(plugins); registerPipelineAggregations(plugins); registerFetchSubPhases(plugins); registerSearchExts(plugins); registerShapes();&#125; 可以看到构造函数中注册了各种搜索模块，而其中就有高亮的注册。 123456789private Map&lt;String, Highlighter&gt; setupHighlighters(Settings settings, List&lt;SearchPlugin&gt; plugins) &#123; NamedRegistry&lt;Highlighter&gt; highlighters = new NamedRegistry&lt;&gt;(\"highlighter\"); highlighters.register(\"fvh\", new FastVectorHighlighter(settings)); highlighters.register(\"plain\", new PlainHighlighter()); highlighters.register(\"unified\", new UnifiedHighlighter()); highlighters.extractAndRegister(plugins, SearchPlugin::getHighlighters); return unmodifiableMap(highlighters.getRegistry());&#125; 首先加载了3个系统自带的高亮类型，然后加载搜索插件中的高亮部分。","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]},{"title":"Elasticsearch-6.2.4插件开发一：插件种类介绍","slug":"Elasticsearch-6.2.4插件开发一：插件种类介绍","date":"2018-11-22T03:03:01.969Z","updated":"2018-11-28T02:38:59.165Z","comments":true,"path":"2018/11/22/Elasticsearch-6.2.4插件开发一：插件种类介绍/","link":"","permalink":"http://yoursite.com/2018/11/22/Elasticsearch-6.2.4插件开发一：插件种类介绍/","excerpt":"","text":"插件开发ES提供两种方式用于插件开发，一种是继承Plugin抽象类，一种是继承Plugin抽象类后再实现相关的插件接口。 插件种类ScriptPlugin：脚本插件，ES默认的脚本语言是Painless，可自定义其他脚本语言，java、js等。 AnalysisPlugin：分析插件，可扩展新的分析器，标记器，标记过滤器或字符过滤器等。 DiscoveryPlugin：发现插件，使集群可以发现节点，如使建立在AWS上的集群可以发现节点。 ClusterPlugin：集群插件，增强对集群的管理，如控制分片位置。 IngestPlugin：摄取插件，增强节点的ingest功能，例如可以在ingest中通过tika解析ppt、pdf内容。 MapperPlugin：映射插件，可添加新的字段类型。 SearchPlugin：搜索插件，扩展搜索功能，如添加新的搜索类型，高亮类型等。 RepositoryPlugin：存储库插件，可添加新的存储库，如S3，Hadoop HDFS等。 ActionPlugin：API扩展插件，可扩展Http的API接口。 NetworkPlugin：网络插件，扩展ES底层的网络传输功能。 除了明确属于不同模块的插件接口外，继承抽象类Plugin可以为索引模块添加新的功能，如添加索引、搜索监听器，新的相似度算法。","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]},{"title":"Elasticsearch-6.2.4源码启动（window环境下）","slug":"Elasticsearch-6.2.4源码启动（window环境下）","date":"2018-11-22T02:37:37.120Z","updated":"2018-11-28T02:39:46.785Z","comments":true,"path":"2018/11/22/Elasticsearch-6.2.4源码启动（window环境下）/","link":"","permalink":"http://yoursite.com/2018/11/22/Elasticsearch-6.2.4源码启动（window环境下）/","excerpt":"","text":"获取源码和可运行的es1.1 首先从github上把es的源码拉下来并切换分支到v6.2.4版本（ps：es不同版本源码启动过程差异可能较大）。 git clone https://github.com/elastic/elasticsearch.git git checkout v6.2.4 （本篇博客命令执行皆使用git bash） 1.2 到官网下载可运行的es 编译源码es是一个gradle项目，导入idea前需执行 gradle idea 命令，不然会报错。 使用项目自带的gradlew编译es源码 ./gradlew idea ./gradlew build （IDE是eclipse的话则将命令中idea替换成eclipse） 国内可能部分包下载不了，可添加gradle国内镜像，在用户目录下的.gradle中新建init.gradle文件： 1234567891011121314allprojects&#123; buildscript &#123; repositories &#123; maven &#123; url \"https://maven.aliyun.com/repository/public\" &#125; jcenter()&#123; url 'http://jcenter.bintray.com/' &#125; &#125; &#125; repositories &#123; maven &#123; url \"http://maven.aliyun.com/nexus/content/groups/public/\" &#125; // 将jcenter的连接改为http jcenter()&#123; url 'http://jcenter.bintray.com/' &#125; &#125;&#125; 编译完成后便可用idea打开项目。 运行es如何从源码运行es？ 我们先参考官网下载的es中，bin目录下的启动脚本elasticsearch，elasticsearch-env 123456789101112(只列出关键部分，其余省略)SCRIPT=\"$0\"ES_HOME=`dirname \"$SCRIPT\"`ES_PATH_CONF=\"$ES_HOME\"/config......\"$JAVA\" \\$ES_JAVA_OPTS \\-Des.path.home=\"$ES_HOME\" \\-Des.path.conf=\"$ES_PATH_CONF\" \\-cp \"$ES_CLASSPATH\" \\org.elasticsearch.bootstrap.Elasticsearch \\...... 可见，es的启动入口为org.elasticsearch.bootstrap.Elasticsearch； es启动需要配置两个启动参数es.path.home和es.path.conf 其中es.path.home是es服务的路径，即es项目中server目录下，es.path.conf为配置文件目录，在server目录下创建config文件夹作为配置文件目录，并直接从官网的es中copy三个配置文件（此处不详解文件具体内容）。 打开idea配置两个启动参数（直接绝对路径即可） 12-Des.path.conf=E:\\......\\elasticsearch\\server\\config-Des.path.home=E:\\......\\elasticsearch\\server 在idea顶层菜单打开Run&gt;Edit Configurations，配置VM options 接下来我们启动试一试：org.elasticsearch.bootstrap.Elasticsearch 直接执行main方法，发现启动失败，出现几个异常： 第一个 原因是es启动时会去扫描主目录下的plugins目录，加载es插件（插件方面将在其他文章说明），所以要创建plugins目录。 第二个 原因是用户没有操作目录的权限 直接在server目录下建立java.policy文件： 123456789grant codeBase \"file:$&#123;&#123;java.ext.dirs&#125;&#125;/*\" &#123; permission java.security.AllPermission; permission java.lang.RuntimePermission \"createClassLoader\";&#125;;grant &#123; permission java.security.AllPermission; permission java.lang.RuntimePermission \"createClassLoader\";&#125;; VM options的配置增加： 123-Des.path.conf=E:\\......\\elasticsearch\\server\\config-Des.path.home=E:\\......\\elasticsearch\\server-Djava.security.policy=E:\\......\\elasticsearch\\server\\java.policy 第三个 原因是相关模块的缺失，es加载为空，直接把官网的es中的modules文件夹整个复制到server目录下就行。 第四个 ExtendedPluginsClassLoader这个类并没有编译出来 至于原因，我们可以在单元测试类test/org.elasticsearch.bootstrap.BootstrapForTesting中看到这一段： 1234if (System.getProperty(\"tests.gradle\") == null) &#123; // intellij and eclipse don't package our internal libs, so we need to set the codebases for them manually addClassCodebase(codebases,\"plugin-classloader\", \"org.elasticsearch.plugins.ExtendedPluginsClassLoader\");&#125; 而idea并不会打包内置的依赖，即传递依赖，在server的build.gradle中： 123456dependencies &#123; ...... compileOnly project(':libs:plugin-classloader') testRuntime project(':libs:plugin-classloader') ......&#125; 可以看到plugin-classloader的编译类型是compileOnly和testRuntime，只在编译阶段编译，在运行阶段不会将这个依赖包括进来，idea是默认不会运行时不包括传递依赖的，可以在这里勾选设置启动将包括该类传递依赖 所有问题解决后便可以顺利启动了。","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/categories/Elasticsearch/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://yoursite.com/tags/Elasticsearch/"}]}]}